#version 460

// ------------- layout ------------- 

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0, rgba8) uniform image2D targetImage[8];

struct Sphere {
  vec3 center;
  float radius;
  uint materialType;
};

struct Triangle {
  vec3 point0;
  vec3 point1;
  vec3 point2;
};

struct BvhNode {
  int leftNode;
  int rightNode;
  int objIndex;

  vec3 maximum;
  vec3 minimum;
};

layout(set = 0, binding = 1) uniform GlobalUbo {
  vec3 origin;
  vec3 horizontal;
  vec3 vertical;
  vec3 lowerLeftCorner;
} ubo;

layout(set = 0, binding = 2) buffer ObjectSsbo {
  Triangle triangles[500];
};

layout(set = 0, binding = 3) buffer BvhSsbo {
  BvhNode bvhNodes[500];
};

layout(set = 0, binding = 4) buffer NumSsbo {
  uint objSize;
  uint bvhSize;
} numSsbo;

layout(push_constant) uniform Push {
  uint randomSeed;
} push;

// ------------- pre-defined parameter -------------

float pi = 3.14159265359;

// ------------- struct ------------- 

struct Ray {
  vec3 origin;
  vec3 direction;
};

struct FaceNormal {
  bool frontFace;
  vec3 normal;
};

struct MaterialHitRecord {
  uint materialType;
};

struct HitRecord {
  bool isHit;
  float t;
  vec3 point;
  FaceNormal faceNormal;
  MaterialHitRecord materialHit;
  vec2 uv;
};

struct ScatterRecord {
  bool isScattered;
  vec3 colorAttenuation;
  Ray raySpecular;
};

// ------------- function ------------- 

#include "helper/random.glsl"

bool nearZero(vec3 xyz) {
  // Return true if the vector is close to zero in all dimensions.
  float s = 1e-8;
  return (abs(xyz.x) < s) && (abs(xyz.y) < s) && (abs(xyz.z) < s);
}

float reflectance(float cosine, float refIdx) {
  // Use Schlick's approximation for reflectance.
  float r0 = (1 - refIdx) / (1 + refIdx);
  r0 = r0 * r0;
  return r0 + (1 - r0) * pow((1 - cosine), 5);
}

vec3 rayAt(Ray r, float t) {
  return r.origin + t * r.direction;
}

FaceNormal setFaceNormal(vec3 r_direction, vec3 outwardNormal) {
  FaceNormal faceNormal;

  faceNormal.frontFace = dot(r_direction, outwardNormal) < 0.0;
  faceNormal.normal = faceNormal.frontFace ? outwardNormal : -1.0 * outwardNormal;

  return faceNormal;
}

HitRecord hitTriangle(Triangle obj, Ray r, float tMin, float tMax) {
  HitRecord rec;
  rec.isHit = false;

  float kEpsilon = 1e-8;

  vec3 v0v1 = obj.point1 - obj.point0;
  vec3 v0v2 = obj.point2 - obj.point0;
  vec3 pvec = cross(normalize(r.direction), v0v2);
  float det = dot(v0v1, pvec);
  
  if (abs(det) < kEpsilon) {
    return rec;
  }
    
  float invDet = 1.0 / det;

  vec3 tvec = r.origin - obj.point0;
  float u = dot(tvec, pvec) * invDet;
  if (u < 0.0 || u > 1.0) {
    return rec;
  }

  vec3 qvec = cross(tvec, v0v1);
  float v = dot(normalize(r.direction), qvec) * invDet;
  if (v < 0.0 || u + v > 1.0) {
    return rec;
  }
  
  float t = dot(v0v2, qvec) * invDet;

  if (t <= kEpsilon) {
    return rec;
  }

  if (t < tMin || t > tMax) {
    return rec;
  }

  rec.isHit = true;
  rec.t = t;
  rec.point = rayAt(r, rec.t);
  rec.uv = vec2(u, v);

  vec3 outwardNormal = normalize(cross(v0v1, v0v2));
  rec.faceNormal = setFaceNormal(normalize(r.direction), outwardNormal);

  // rec.faceNormal.normal = -1.0 * outwardNormal;

  rec.materialHit.materialType = 1;
  return rec;
}

vec2 getSphereUV(vec3 point) {
  float pi = 3.1415926535897932385;

  float theta = acos(-1.0 * point.y);
  float phi = atan(point.x, -1.0 * point.z) + pi; // HLSL atan2(x,y) == GLSL atan(y,x)

  float u = phi / (2.0 * pi);
  float v = theta / pi;

  return vec2(u, v);
}

HitRecord hitSphere(Sphere obj, Ray r, float tMin, float tMax) {
  HitRecord rec;
  rec.isHit = false;

  vec3 oc = r.origin - obj.center;

  float a = dot(r.direction, r.direction);
  float half_b = dot(oc, r.direction);
  float c = dot(oc, oc) - obj.radius * obj.radius;

  float discriminant = half_b * half_b - a * c;

  if (discriminant < 0.0) {
    return rec;
  }

  float sqrtd = sqrt(discriminant);

  // Find the nearest root that lies in the acceptable range.
  float root = (-half_b - sqrtd) / a;
  if (root < tMin || root > tMax) {
    root = (-half_b + sqrtd) / a;
    if (root < tMin || root > tMax) {
      return rec;
    }
  }

  rec.isHit = true;
  rec.t = root;
  rec.point = rayAt(r, rec.t);
  rec.uv = getSphereUV(rec.point);

  vec3 outwardNormal = (rec.point - obj.center) / obj.radius;
  rec.faceNormal = setFaceNormal(r.direction, outwardNormal);

  rec.materialHit.materialType = obj.materialType;
  return rec;
}

HitRecord hitTriangleList(Triangle objList[500], uint objNum, Ray r, float tMin, float tMax) {
  HitRecord rec;
  rec.isHit = false;
  rec.t = tMax;

  for (int i = 0; i < objNum; i++) {
    HitRecord tempRec = hitTriangle(objList[i], r, tMin, rec.t);
    if (tempRec.isHit) {
      rec = tempRec;
    }
  }

  return rec;
}

HitRecord hitSphereList(Sphere objList[500], uint objNum, Ray r, float tMin, float tMax) {
  HitRecord rec;
  rec.isHit = false;
  rec.t = tMax;
  
  for (int i = 0; i < objNum; i++) {
    HitRecord tempRec = hitSphere(objList[i], r, tMin, rec.t);
    if (tempRec.isHit) {
      rec = tempRec;
    }
  }

  return rec;
}

vec2 intersectAABB(Ray r, vec3 boxMin, vec3 boxMax) {
  vec3 tMin = (boxMin - r.origin) / r.direction;
  vec3 tMax = (boxMax - r.origin) / r.direction;
  vec3 t1 = min(tMin, tMax);
  vec3 t2 = max(tMin, tMax);
  float tNear = max(max(t1.x, t1.y), t1.z);
  float tFar = min(min(t2.x, t2.y), t2.z);

  return vec2(tNear, tFar);
}

#define MAX_NODE_DEPTH 25
HitRecord hitBvh(BvhNode objList[500], uint objNum, Ray r, float tMin, float tMax) {
  HitRecord rec;
  rec.isHit = false;
  rec.t = tMax;

  int stack[MAX_NODE_DEPTH];
  int stackIndex = 0;

  stack[stackIndex] = 0;
  stackIndex++;

  while(stackIndex > 0 && stackIndex < MAX_NODE_DEPTH) {
    stackIndex--;
    int currentNode = stack[stackIndex];
    if (currentNode < 0) {
      continue;
    }

    vec2 intersect = intersectAABB(r, bvhNodes[currentNode].minimum, bvhNodes[currentNode].maximum);
    if (intersect.x > intersect.y) {
      continue;
    }

    if (bvhNodes[currentNode].objIndex > 0) {
      int objIndex = bvhNodes[currentNode].objIndex;
      HitRecord tempRec = hitTriangle(triangles[objIndex], r, tMin, rec.t);

      if (tempRec.isHit) {
        rec = tempRec;
      }
    }

    stack[stackIndex] = bvhNodes[currentNode].leftNode;
    stackIndex++;

    stack[stackIndex] = bvhNodes[currentNode].rightNode;
    stackIndex++;
  }

  return rec;
}

ScatterRecord scatterLambertian(Ray r, HitRecord hit) {
  ScatterRecord scat;

  vec3 scatterDirection = hit.faceNormal.normal + normalize(randomInUnitSphere(0));
  if (nearZero(scatterDirection)) {
    scatterDirection = hit.faceNormal.normal;
  }

  scat.raySpecular.origin = hit.point;
  scat.raySpecular.direction = scatterDirection;

  scat.isScattered = true;
  scat.colorAttenuation = vec3(0.5, 0.4, 0.2);

  return scat;
}

ScatterRecord scatterMetal(Ray r, HitRecord hit) {
  ScatterRecord scat;

  vec3 reflected = reflect(normalize(r.direction), hit.faceNormal.normal);

  float fuzziness = 0.0;
  // fuzziness = min(fuzziness, 1.0);

  scat.raySpecular.origin = hit.point;
  scat.raySpecular.direction = reflected + fuzziness * randomInUnitSphere(0);

  scat.isScattered = dot(scat.raySpecular.direction, hit.faceNormal.normal) > 0.0;
  scat.colorAttenuation = vec3(0.7, 0.6, 0.3);

  return scat;
}

ScatterRecord scatterDielectric(Ray r, HitRecord hit) {
  ScatterRecord scat;

  float indexOfRefraction = 1.5;
  float refractionRatio = hit.faceNormal.frontFace ? (1.0 / indexOfRefraction) : indexOfRefraction;

  vec3 unitDirection = normalize(r.direction);
  float cosTheta = min(dot(-unitDirection, hit.faceNormal.normal), 1.0);
  float sinTheta = sqrt(1.0 - cosTheta * cosTheta);

  bool cannotRefract = refractionRatio * sinTheta > 1.0;
  vec3 direction;

  if (cannotRefract || reflectance(cosTheta, refractionRatio) > randomFloat(0)) {
    direction = reflect(unitDirection, hit.faceNormal.normal);
  } else {
    direction = refract(unitDirection, hit.faceNormal.normal, refractionRatio);
  }

  scat.raySpecular.origin = hit.point;
  scat.raySpecular.direction = direction;

  scat.isScattered = true;
  scat.colorAttenuation = vec3(1.0, 1.0, 1.0);

  return scat;
}

vec3 rayColor(Ray r) {
  Ray curRay = r;
  vec3 curAttenuation = vec3(1.0, 1.0, 1.0);
  
  for(int i = 0; i < 50; i++) {
    HitRecord hit = hitTriangleList(triangles, numSsbo.objSize, curRay, 0.001, 10000.0); // hitBvh(bvhNodes, 23, curRay, 0.001, 10000.0);

    if (hit.isHit) {
      ScatterRecord scat;
      scat.isScattered = false;

      if (hit.materialHit.materialType == 0) {
        scat = scatterLambertian(curRay, hit);
      } else if (hit.materialHit.materialType == 1) {
        scat = scatterMetal(curRay, hit);
      } else if (hit.materialHit.materialType == 2) {
        scat = scatterDielectric(curRay, hit);
      }

      if (scat.isScattered) {
        curAttenuation *= scat.colorAttenuation;
        curRay = scat.raySpecular;
      } else {
        return vec3(1.0, 0.0, 0.0);
      }
    } else {
      vec3 unit_direction = normalize(curRay.direction);
      float t = 0.5 * (unit_direction.y + 1.0);
      vec3 c = (1.0 - t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0);

      return curAttenuation * c;
    }
  }

  return vec3(0.0, 0.0, 1.0); // exceeded recursion
}

void main() {
  uint imgIndex = gl_GlobalInvocationID.z;
  uvec2 imgPosition = gl_GlobalInvocationID.xy;

  vec2 imgSize = vec2(imageSize(targetImage[imgIndex]));

  float noiseX = randomFloat(1);
  float noiseY = randomFloat(2);

  vec2 noiseUV = vec2(noiseX, noiseY);
  vec2 uv = (imgPosition + noiseUV) / imgSize;

  Ray r;
  r.origin = ubo.origin;
  r.direction = ubo.lowerLeftCorner + uv.x * ubo.horizontal - uv.y * ubo.vertical - ubo.origin;
  
  vec4 curColor = vec4(rayColor(r), 1.0);
  imageStore(targetImage[imgIndex], ivec2(imgPosition), curColor);
}